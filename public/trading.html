<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Harry Schlote</title>
  <link rel="stylesheet" href="style.css">
  <link rel="icon" href="assets/faviconharryschlote.png">
  <link rel="apple-touch-icon" href="assets/webclipharryschlote.png">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;0,500;0,600;0,700;1,300;1,400;1,500;1,600;1,700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/dark.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
</head>
<body>
  <!-- Navbar -->
  <div id="instance-nav"></div>

  <div class="banner-div" id="trading-banner">
    <div class="gradient">
    <div class="max-1160" id="vertical">
        <h0>An Introduction to Systematic Trading Strategies</h0>
        <div class="item-tags" id="white">September 21, 2022 | Quant Strategy</div>
      </div>
    </div>
  </div>


  <div id="popup">Webpage link copied to clipboard.</div>

  <!-- Content -->
  <div id="container">

    
      <div class="article-para">
      <div class="article-bar">
        <div class="authors">
          By <a href="https://www.linkedin.com/in/harry-schlote-60a331202/" class="author-link">Harry Schlote</a>
        </div>
        <div class="article-icon-bar">
          <!-- download button -->
          <a id="downloadButton" class="copy-button" href="projects/Strategy_Scripts.zip" download>
          <svg class="article-download" width="252" height="147" viewBox="0 0 252 147" fill="none" xmlns="http://www.w3.org/2000/svg">
            <g clip-path="url(#clip0_90_32)">
            <path fill="currentColor" d="M16.7216 140H5.21591V100.727H17.4119C21.1577 100.727 24.3601 101.507 27.0192 103.067C29.6911 104.626 31.7365 106.864 33.1555 109.778C34.5746 112.693 35.2841 116.19 35.2841 120.268C35.2841 124.384 34.5554 127.919 33.098 130.872C31.6534 133.812 29.544 136.069 26.7699 137.641C24.0085 139.214 20.6591 140 16.7216 140ZM8.80185 136.778H16.5107C19.8857 136.778 22.7109 136.114 24.9865 134.784C27.2621 133.455 28.9688 131.556 30.1065 129.089C31.2443 126.621 31.8132 123.681 31.8132 120.268C31.8004 116.88 31.2379 113.965 30.1257 111.523C29.0263 109.082 27.3899 107.209 25.2166 105.905C23.0561 104.601 20.3842 103.949 17.201 103.949H8.80185V136.778ZM54.7143 140.614C52.1703 140.614 49.9203 139.968 47.9643 138.677C46.0211 137.386 44.4998 135.602 43.4004 133.327C42.301 131.038 41.7512 128.398 41.7512 125.407C41.7512 122.39 42.301 119.737 43.4004 117.449C44.4998 115.148 46.0211 113.358 47.9643 112.08C49.9203 110.788 52.1703 110.143 54.7143 110.143C57.2583 110.143 59.502 110.788 61.4451 112.08C63.3883 113.371 64.9096 115.161 66.0091 117.449C67.1213 119.737 67.6774 122.39 67.6774 125.407C67.6774 128.398 67.1277 131.038 66.0282 133.327C64.9288 135.602 63.4011 137.386 61.4451 138.677C59.502 139.968 57.2583 140.614 54.7143 140.614ZM54.7143 137.488C56.7598 137.488 58.492 136.938 59.911 135.839C61.3301 134.739 62.4039 133.276 63.1326 131.447C63.8741 129.619 64.2449 127.606 64.2449 125.407C64.2449 123.208 63.8741 121.188 63.1326 119.347C62.4039 117.506 61.3301 116.03 59.911 114.918C58.492 113.805 56.7598 113.249 54.7143 113.249C52.6816 113.249 50.9494 113.805 49.5176 114.918C48.0985 116.03 47.0183 117.506 46.2768 119.347C45.5481 121.188 45.1838 123.208 45.1838 125.407C45.1838 127.606 45.5481 129.619 46.2768 131.447C47.0183 133.276 48.0985 134.739 49.5176 135.839C50.9366 136.938 52.6689 137.488 54.7143 137.488ZM80.7076 140L71.8098 110.545H75.415L82.3951 134.842H82.6444L89.6053 110.545H93.2296L100.133 134.784H100.401L107.382 110.545H110.987L102.089 140H98.5605L91.5804 115.857H91.2161L84.236 140H80.7076ZM121.035 121.591V140H117.622V110.545H120.939V115.167H121.246C121.936 113.658 123.01 112.45 124.468 111.543C125.938 110.622 127.753 110.162 129.914 110.162C131.895 110.162 133.634 110.577 135.129 111.408C136.638 112.227 137.808 113.435 138.639 115.033C139.482 116.631 139.904 118.593 139.904 120.92V140H136.491V121.131C136.491 118.714 135.813 116.803 134.458 115.397C133.116 113.991 131.313 113.288 129.051 113.288C127.504 113.288 126.129 113.62 124.928 114.285C123.726 114.95 122.774 115.908 122.07 117.161C121.38 118.401 121.035 119.878 121.035 121.591ZM152.306 100.727V140H148.893V100.727H152.306ZM172.787 140.614C170.243 140.614 167.993 139.968 166.037 138.677C164.093 137.386 162.572 135.602 161.473 133.327C160.373 131.038 159.824 128.398 159.824 125.407C159.824 122.39 160.373 119.737 161.473 117.449C162.572 115.148 164.093 113.358 166.037 112.08C167.993 110.788 170.243 110.143 172.787 110.143C175.331 110.143 177.574 110.788 179.517 112.08C181.461 113.371 182.982 115.161 184.081 117.449C185.194 119.737 185.75 122.39 185.75 125.407C185.75 128.398 185.2 131.038 184.1 133.327C183.001 135.602 181.473 137.386 179.517 138.677C177.574 139.968 175.331 140.614 172.787 140.614ZM172.787 137.488C174.832 137.488 176.564 136.938 177.983 135.839C179.402 134.739 180.476 133.276 181.205 131.447C181.946 129.619 182.317 127.606 182.317 125.407C182.317 123.208 181.946 121.188 181.205 119.347C180.476 117.506 179.402 116.03 177.983 114.918C176.564 113.805 174.832 113.249 172.787 113.249C170.754 113.249 169.022 113.805 167.59 114.918C166.171 116.03 165.091 117.506 164.349 119.347C163.62 121.188 163.256 123.208 163.256 125.407C163.256 127.606 163.62 129.619 164.349 131.447C165.091 133.276 166.171 134.739 167.59 135.839C169.009 136.938 170.741 137.488 172.787 137.488ZM201.469 140.671C199.692 140.671 198.069 140.326 196.599 139.636C195.128 138.933 193.959 137.923 193.089 136.606C192.22 135.276 191.785 133.665 191.785 131.773C191.785 130.316 192.06 129.089 192.61 128.092C193.16 127.094 193.939 126.276 194.949 125.637C195.959 124.998 197.155 124.493 198.535 124.122C199.916 123.751 201.437 123.464 203.099 123.259C204.748 123.055 206.142 122.876 207.28 122.722C208.43 122.569 209.306 122.326 209.907 121.994C210.508 121.661 210.808 121.124 210.808 120.383V119.692C210.808 117.685 210.207 116.107 209.006 114.956C207.817 113.793 206.104 113.211 203.866 113.211C201.744 113.211 200.012 113.678 198.67 114.611C197.34 115.544 196.407 116.643 195.87 117.909L192.629 116.739C193.294 115.129 194.214 113.844 195.39 112.885C196.567 111.913 197.883 111.217 199.341 110.795C200.798 110.36 202.275 110.143 203.77 110.143C204.895 110.143 206.065 110.29 207.28 110.584C208.507 110.878 209.645 111.389 210.693 112.118C211.741 112.834 212.591 113.837 213.243 115.129C213.895 116.407 214.221 118.031 214.221 119.999V140H210.808V135.34H210.597C210.188 136.21 209.581 137.053 208.775 137.871C207.97 138.69 206.96 139.361 205.746 139.885C204.531 140.409 203.106 140.671 201.469 140.671ZM201.93 137.545C203.745 137.545 205.317 137.143 206.647 136.337C207.976 135.532 208.999 134.464 209.715 133.135C210.444 131.793 210.808 130.316 210.808 128.705V124.448C210.552 124.691 210.124 124.908 209.523 125.1C208.935 125.292 208.251 125.464 207.471 125.618C206.704 125.759 205.937 125.88 205.17 125.982C204.403 126.085 203.713 126.174 203.099 126.251C201.437 126.455 200.018 126.775 198.842 127.21C197.666 127.644 196.765 128.245 196.138 129.012C195.512 129.766 195.199 130.738 195.199 131.927C195.199 133.717 195.838 135.104 197.116 136.088C198.395 137.06 199.999 137.545 201.93 137.545ZM233.906 140.614C231.49 140.614 229.374 139.974 227.558 138.696C225.743 137.418 224.324 135.634 223.301 133.346C222.291 131.058 221.786 128.392 221.786 125.349C221.786 122.32 222.291 119.667 223.301 117.391C224.324 115.103 225.749 113.326 227.578 112.06C229.406 110.782 231.534 110.143 233.963 110.143C235.753 110.143 237.242 110.462 238.431 111.102C239.62 111.728 240.573 112.508 241.289 113.441C242.004 114.374 242.561 115.282 242.957 116.164H243.264V100.727H246.696V140H243.36V134.535H242.957C242.561 135.43 241.998 136.35 241.269 137.296C240.541 138.229 239.575 139.016 238.374 139.655C237.185 140.294 235.695 140.614 233.906 140.614ZM234.308 137.488C236.213 137.488 237.837 136.97 239.179 135.935C240.521 134.886 241.544 133.448 242.247 131.62C242.963 129.779 243.321 127.67 243.321 125.292C243.321 122.94 242.97 120.862 242.267 119.06C241.563 117.244 240.541 115.825 239.198 114.803C237.856 113.767 236.226 113.249 234.308 113.249C232.34 113.249 230.678 113.786 229.323 114.86C227.98 115.921 226.958 117.359 226.254 119.175C225.564 120.99 225.219 123.029 225.219 125.292C225.219 127.58 225.57 129.645 226.274 131.486C226.977 133.327 227.999 134.79 229.342 135.877C230.697 136.951 232.352 137.488 234.308 137.488Z"/>
            <path id="download-lines" stroke="currentColor" d="M87 76H159" stroke-width="3" stroke-linecap="round"/>
            <path fill="currentColor" d="M121.939 65.0607C122.525 65.6464 123.475 65.6464 124.061 65.0607L133.607 55.5147C134.192 54.9289 134.192 53.9792 133.607 53.3934C133.021 52.8076 132.071 52.8076 131.485 53.3934L123 61.8787L114.515 53.3934C113.929 52.8076 112.979 52.8076 112.393 53.3934C111.808 53.9792 111.808 54.9289 112.393 55.5147L121.939 65.0607ZM124.5 6C124.5 5.17157 123.828 4.5 123 4.5C122.172 4.5 121.5 5.17157 121.5 6L124.5 6ZM124.5 64L124.5 6L121.5 6L121.5 64L124.5 64Z"/>
            <path id="download-lines" stroke="currentColor" d="M113.5 54.5L102 43M132 55L144 43" stroke-width="3" stroke-linejoin="round"/>
            </g>
            <defs>
            <clipPath  id="clip0_90_32">
            <rect  width="252" height="147" fill="white"/>
            </clipPath>
            </defs>
          </svg>
          </a>
          <!-- share button -->
          <button id="copyButton" class="copy-button">
            <svg class="article-icon" width="147" height="147" viewBox="0 0 147 147" fill="none" xmlns="http://www.w3.org/2000/svg">
              <circle cx="92.5" cy="18.5" r="10" stroke="currentColor" stroke-width="3"/>
              <circle cx="92.5" cy="62.5" r="10" stroke="currentColor" stroke-width="3"/>
              <circle cx="52.5" cy="40.5" r="10" stroke="currentColor" stroke-width="3"/>
              <line x1="60.7183" y1="46.6832" x2="82.7183" y2="58.6832" stroke="currentColor" stroke-width="3"/>
              <line y1="-1.5" x2="25.0599" y2="-1.5" transform="matrix(-0.877896 0.478852 0.478852 0.877896 84 23)" stroke="currentColor" stroke-width="3"/>
              <path fill="currentColor" d="M26.5398 109.545C26.3224 107.359 25.3572 105.621 23.6442 104.33C21.9311 103.038 19.777 102.393 17.1818 102.393C15.3537 102.393 13.7429 102.706 12.3494 103.332C10.9688 103.959 9.8821 104.828 9.08949 105.94C8.30966 107.04 7.91974 108.293 7.91974 109.699C7.91974 110.734 8.14347 111.642 8.59091 112.422C9.03835 113.202 9.6392 113.873 10.3935 114.435C11.1605 114.985 12.0043 115.458 12.9247 115.854C13.858 116.251 14.7976 116.583 15.7436 116.852L19.8857 118.04C21.1385 118.386 22.3913 118.827 23.6442 119.364C24.897 119.901 26.0412 120.578 27.0767 121.396C28.125 122.202 28.9624 123.192 29.5888 124.369C30.228 125.532 30.5476 126.932 30.5476 128.568C30.5476 130.665 30.0043 132.55 28.9176 134.225C27.831 135.9 26.2713 137.229 24.2386 138.214C22.206 139.185 19.7706 139.671 16.9325 139.671C14.2607 139.671 11.9403 139.23 9.97159 138.348C8.00284 137.453 6.45597 136.219 5.33097 134.647C4.20597 133.075 3.57315 131.253 3.43253 129.182H7.11435C7.24219 130.729 7.75355 132.039 8.64844 133.113C9.54332 134.187 10.7067 135.005 12.1385 135.567C13.5703 136.117 15.1683 136.392 16.9325 136.392C18.8885 136.392 20.6271 136.066 22.1484 135.414C23.6825 134.749 24.8842 133.829 25.7536 132.653C26.6357 131.464 27.0767 130.083 27.0767 128.511C27.0767 127.181 26.7315 126.069 26.0412 125.174C25.3509 124.266 24.3857 123.506 23.1456 122.892C21.9183 122.278 20.4929 121.735 18.8693 121.262L14.1712 119.881C11.0902 118.961 8.69957 117.689 6.99929 116.065C5.29901 114.442 4.44886 112.371 4.44886 109.852C4.44886 107.743 5.01136 105.889 6.13636 104.291C7.27415 102.68 8.80824 101.428 10.7386 100.533C12.6818 99.625 14.8615 99.1712 17.2777 99.1712C19.7195 99.1712 21.88 99.6186 23.7592 100.513C25.6385 101.408 27.1278 102.642 28.2273 104.214C29.3395 105.774 29.934 107.551 30.0107 109.545H26.5398ZM41.8807 120.591V139H38.4673V99.7273H41.8807V114.167H42.1875C42.8778 112.646 43.9453 111.431 45.3899 110.523C46.8473 109.616 48.6882 109.162 50.9126 109.162C52.907 109.162 54.6584 109.571 56.1669 110.389C57.6754 111.207 58.8516 112.415 59.6953 114.013C60.5391 115.612 60.9609 117.58 60.9609 119.92V139H57.5284V120.131C57.5284 117.702 56.8509 115.79 55.4957 114.397C54.1534 112.991 52.3381 112.288 50.0497 112.288C48.4773 112.288 47.0774 112.62 45.8501 113.285C44.6229 113.95 43.6513 114.908 42.9354 116.161C42.2322 117.401 41.8807 118.878 41.8807 120.591ZM78.1763 139.671C76.3993 139.671 74.7757 139.326 73.3056 138.636C71.8354 137.933 70.6657 136.923 69.7963 135.606C68.927 134.276 68.4924 132.665 68.4924 130.773C68.4924 129.316 68.7672 128.089 69.3169 127.092C69.8667 126.094 70.6465 125.276 71.6564 124.637C72.6664 123.998 73.8617 123.493 75.2424 123.122C76.623 122.751 78.1444 122.464 79.8063 122.259C81.4554 122.055 82.8489 121.876 83.9867 121.722C85.1373 121.569 86.013 121.326 86.6138 120.994C87.2147 120.661 87.5151 120.124 87.5151 119.383V118.692C87.5151 116.685 86.9142 115.107 85.7125 113.956C84.5236 112.793 82.8105 112.211 80.5733 112.211C78.4512 112.211 76.7189 112.678 75.3766 113.611C74.0471 114.544 73.1138 115.643 72.5769 116.909L69.3361 115.739C70.0009 114.129 70.9213 112.844 72.0975 111.885C73.2736 110.913 74.5904 110.217 76.0478 109.795C77.5051 109.36 78.9817 109.143 80.4775 109.143C81.6025 109.143 82.7722 109.29 83.9867 109.584C85.214 109.878 86.3517 110.389 87.4 111.118C88.4483 111.834 89.2985 112.837 89.9505 114.129C90.6025 115.407 90.9284 117.031 90.9284 118.999V139H87.5151V134.34H87.3042C86.8951 135.21 86.2878 136.053 85.4824 136.871C84.677 137.69 83.6671 138.361 82.4526 138.885C81.2381 139.409 79.8127 139.671 78.1763 139.671ZM78.6365 136.545C80.4519 136.545 82.0243 136.143 83.3539 135.337C84.6834 134.532 85.7061 133.464 86.4221 132.135C87.1507 130.793 87.5151 129.316 87.5151 127.705V123.448C87.2594 123.691 86.8311 123.908 86.2303 124.1C85.6422 124.292 84.9583 124.464 84.1784 124.618C83.4114 124.759 82.6444 124.88 81.8773 124.982C81.1103 125.085 80.4199 125.174 79.8063 125.251C78.1444 125.455 76.7253 125.775 75.5492 126.21C74.373 126.644 73.4718 127.245 72.8453 128.012C72.2189 128.766 71.9057 129.738 71.9057 130.927C71.9057 132.717 72.5449 134.104 73.8233 135.088C75.1017 136.06 76.7061 136.545 78.6365 136.545ZM100.008 139V109.545H103.326V114.071H103.575C104.163 112.588 105.186 111.393 106.643 110.485C108.113 109.565 109.775 109.104 111.629 109.104C111.91 109.104 112.224 109.111 112.569 109.124C112.914 109.136 113.202 109.149 113.432 109.162V112.633C113.278 112.607 113.01 112.569 112.626 112.518C112.243 112.467 111.827 112.441 111.38 112.441C109.846 112.441 108.478 112.767 107.276 113.419C106.087 114.058 105.148 114.947 104.457 116.085C103.767 117.222 103.422 118.52 103.422 119.977V139H100.008ZM130.268 139.614C127.52 139.614 125.142 138.974 123.135 137.696C121.128 136.405 119.574 134.621 118.475 132.346C117.388 130.058 116.845 127.424 116.845 124.445C116.845 121.479 117.388 118.846 118.475 116.545C119.574 114.231 121.089 112.422 123.02 111.118C124.963 109.801 127.206 109.143 129.751 109.143C131.349 109.143 132.889 109.437 134.372 110.025C135.855 110.6 137.184 111.489 138.361 112.69C139.55 113.879 140.489 115.381 141.18 117.197C141.87 118.999 142.215 121.134 142.215 123.602V125.289H119.204V122.278H138.725C138.725 120.386 138.341 118.686 137.574 117.178C136.82 115.656 135.765 114.455 134.41 113.572C133.068 112.69 131.515 112.249 129.751 112.249C127.884 112.249 126.241 112.748 124.822 113.745C123.403 114.742 122.291 116.059 121.486 117.695C120.693 119.332 120.29 121.121 120.278 123.065V124.867C120.278 127.207 120.68 129.252 121.486 131.004C122.304 132.742 123.461 134.091 124.956 135.05C126.452 136.009 128.223 136.488 130.268 136.488C131.662 136.488 132.883 136.271 133.931 135.836C134.992 135.401 135.881 134.82 136.596 134.091C137.325 133.349 137.875 132.538 138.246 131.656L141.486 132.71C141.039 133.95 140.304 135.094 139.281 136.143C138.271 137.191 137.006 138.035 135.484 138.674C133.976 139.3 132.237 139.614 130.268 139.614Z" fill="currentColor"/>
              </svg>
          </button>
        </div>
      </div>
      </div>

    <div class="main-section">
      <div class="article-para">
        <b>In the dynamic world of finance, mastering trading requires a deep dive into advanced strategies. From approaches like sentiment analysis to RSI momentum, diverse tactics shape investors' paths. This article explores these strategies, revealing their mechanics, applications, and significance in modern markets. If you are new into this space, this guide offers insights for success.</b>
        <h2>Buy and Hold</h2>
        <p>Simply buying and holding each selected asset with an equal weighting that is inputted into the strategy. This is achieved by first defining a pandas dataframe full of ones and then dividing through by the number of tickers (or codes). Although this isn't much of an algorithm, it is useful for seeing how the skeleton code (Strategies class) works. Look at other algorithms for the application of this class to more complex strategies.</p>
        <div class="code-caption"><i>Code Snippet 1. Buy & Hold</i></div>
        <pre>
          <code>
'''
Install yfinance if not installed to run
'''
#pip install yfinance


import numpy as np
import pandas as pd
import pandas_datareader as pdr
import yfinance as yf
import matplotlib.pyplot as plt
import datetime


'''
Setting up class
'''
class Strategies():
    #A class that contains code that strategies later on will inherit from params:
    #codes = list of stock short codes


    #Every class has to have an init method and they define the class specific features.
    #In this case ticker list and two empty dataframes
    def __init__(self,codes):
    #this defines class spacific values
        #so ticker/code list
        self.codes = codes
        #creates 2 empty dataframes
        self.strat = pd.DataFrame()
        self.data = pd.DataFrame()



    def import_data(self, start_date, end_date):
    #this method downloads all data for each backtest from yahoo Finance.
    #and removes any nan values

        #start_date, end_date = string of dates for backtesting with format y-m-d
        #code is another name for ticker
        data = yf.download(self.codes, start_date, end_date)

        #if only one stock code is entered, data is reformatted so that is it the same format as if multiple stock were entered
        if len(self.codes) == 1:
            data.columns = [data.columns, self.codes*len(data.columns)]

        #returns data, and NAN values are removed
        return data.dropna()




    def backtest(self, start_date, end_date):
    #returns a list with elements of a time series from yfinance as well as an array of values between -1 and 1 that represent the strategy over the given period
    #1 represents a long position in one stock, 0 representing a neutral postiion and -1 representing a short position

        #sets up dataframes (defined in the init) to contain data in 1, and then all value weights from the strategy for each stock in the other dataframe
        self.data = self.import_data(start_date, end_date)
        #fills the dataframe with zeros
        self.strat = pd.DataFrame(data = np.zeros([len(self.data), len(self.codes)]), columns = self.codes, index = self.data.index)




    #evaluate method takes a backtest, and evaluates it so calcualte cumulative returns, sharpe and sortino ratios
    def evaluate(self, start_date, end_date, fig_strat=True, fig_other=False, percentage_risk_free_rate = 0.1, **kwargs):
    #returns a dataframe with columns including the daily returns of the portfolio, the cumulative returns, the sharpe ratio and all relevent plot of both the stock price of each stock
    #fig = boolean variable that can be used to produce figures
    #ris_free_rate = average rate of return from a save government issued bond used to calcualte sharpe ratio with
    #**kwargs = any specific keyword arguments that can be passed to the backtesting function to allow for comparison of the backtest for different possible parameters defined in the subclass

        #run the backtest function and define the stock price data to be once again self.data and signals self.strat
        self.strat = self.backtest(start_date, end_date, **kwargs)

        #convert the monthly risk free rate to the daily risk free rate for use when calculating sharpe and sortino ratios
        #e.g. (1+1/100)**(1/21)-1 = (1.01**(0.05)) - 1 =  0.00047 (look up EAR formula)
        #the value of 21 is due to there being 20 trading days in a month
        daily_rate = (1 + percentage_risk_free_rate/100)**(1/21) - 1

        #sets up  new DataFrame which will give the returns of the portfolio
        return_df = pd.DataFrame(columns=["daily returns", "cumulative returns"], index = self.data.index)
        #set return on day 0 to 0
        return_df["daily returns"][0] = 0

        #loops through remaining dates and calculates returns across the portfolio
        for i in range(1, len(self.data)):
            #for each stock, this is 100*value weighting from strategy the previous day*(closing price on current day X - closing price on day X-1)/(closing price on day X-1)
            #hence why if your value weighting is 1 (long position), and the stock goes up, your daily return is posiitve
            #if your weighting is -1 (short position), and the stock goes down, then your daily return is positive
            #this is then summed for the multiple stocks in the portfolio and the portfolio daily returns are given
            return_df["daily returns"][i] = sum(100*self.strat[c][i-1]*(self.data["Adj Close"][c][i]-self.data["Adj Close"][c][i-1])/self.data["Adj Close"][c][i-1] for c in self.codes)

        #calculates the cumulative return for each date
        #it does this by taking the daily return percentage, dividing my 100 and adding 1 to get it into a increase/decrease
        #e.g. daily return of 7% goes >>  (7/100)+1 = 1.07 This happens for all the values in the dataframe
        #then the cumprod returns the cumulative product of a dataframe (NOT SUM) e.g. 1.07*0.96*1.02 not 1.07+0.96+1.02
        #this results is then -1 and multiplied by 100... e.g. (1.12-1)*100 = 12%
        return_df["cumulative returns"] = (((return_df["daily returns"]/100)+1).cumprod()-1)*100
        return_df.dropna()


        #For each of the strategies we went through in the notebook they all require a calculations involving a certain
        #number of historic values. e.g previous percentage returns. As a result our strategies can't start straight away
        #as we need to wait until we have enough previous pieces of data for the code to work and produce signals.

        #calculates the length of time for which the strategy is inactive to begin with
        zero_count = 0
        #While True will run forever until a break command is run.
        while True:
            if sum(abs(self.strat[c].iloc[zero_count]) for c in self.codes):
                #by using iloc[zero_count] when zero_count is 0 it looks at first row, in this is zero then zero_count = 1
                #and then it becomes iloc[1] which searches the second row in the strat dataframe
                #and so on....
                break
            zero_count += 1

            #python syntax allows for the simplification of
            #if not sum(abs(self.strat[c].iloc[zero_count]) for c in self.codes) == 0:
            #to
            #if sum(abs(self.strat[c].iloc[zero_count]) for c in self.codes):

            #^^^^ this basically says that if the rows equals zero, then carry on but if it doesnt equal zero then break
            #so if it is zero 5 times, it bypasses the break and adds to the zero_count, but then the first nonzero value
            #breaks the loop and the while becomes false, and the 5 is stored in zero_count



        #calculates the sharpe ratio, not including the first period of inactivity

        #Sharpe ratio is the sum of the differences in daily returns of the strategy and the risk-free rate
        #over a given period is divivded by the standard devisation of all daily returns.
        #( all return percentages summed/100 - (risk free rate * number of days) ) / standard devisation of all daily returns
        #e.g. ((1.02+0.95+1.06+1.03)/100 - 4*0.0005) / 0.03 = 1.29
        sharpe = ((return_df["daily returns"][zero_count:].sum()/100 - len(return_df[zero_count:]) * daily_rate) / return_df["daily returns"][zero_count:].std())
        print('Sharpe: ', sharpe)

        #Sortino ratio is similar, however we divide by the standard deviation of only the negative or downwards
        #returns (inferring that we only care about negative volatility)
        #This doesnt include the zero_count index in denominator, as there are no negative downturns anyway when there are 0 values, so these are filtered out
        sortino = ((return_df["daily returns"][zero_count:].sum()/100 - len(return_df[zero_count:]) * daily_rate) / return_df["daily returns"][(return_df["daily returns"] < 0)].std())
        print('Sortino: ', sortino)



        #plots figures if fig_strat = TRUE
        if fig_strat:
            #plot of strategy returns
            plt.figure()
            plt.title("Strategy Backtest from" + start_date + " to " + end_date)
            plt.plot(return_df["cumulative returns"])
            plt.show()

        #plots figure if fig_other = TRUE
        if fig_other:
            #plot of all inidividual stocks
            for c in self.codes:
                plt.figure()
                plt.title("Buy and Hold from" + start_date + " to " + end_date + " for " + str(c))
                plt.plot(((self.data["Adj Close"][c].pct_change()+1).cumprod()-1)*100)
                plt.show()
        print('Returns: ', return_df)
        return [return_df, sharpe, sortino]


'''
Class specifically for Buy and Hold Strat
'''
#this inherits all of the methods from the Strategies class
#this strategy as the name suggest buys and holds an equal amount of each security
class StrategyBuyAndHold(Strategies):

    def backtest(self, start_date, end_date):

        Strategies.backtest(self, start_date, end_date)
        #creates a normalised set of weightings representing a buy and hold strat with each column summing to one

        #this fills the dataframe with data = ones, but divides by number of stocks to ensure equal distribution
        ##e.g. if you have gc=f,aapl,ride (3stocks), then the dataframe is filled with 1/3
        #then the columns are the ticker codes
        return pd.DataFrame(data = (np.ones([len(self.data), len(self.codes)])/len(self.codes)), columns = self.codes)




'''
Example of a backtest for this Strategy
'''
testbh = StrategyBuyAndHold((["^FTSE","^GSPC","AAPL","GC=F","ZC=F"]))
#the code(ticker) is GC=F, AAPL, RIDE then the start_date and end_date are below, and the fig_other is set to TRUE
testbh.evaluate("2020-07-24","2022-07-24", fig_other = True)
#this basically creates an instance os the StrategyBuyAndHold and inputs the 3 stocks into it.
#it also automatically runs the __init__ so creates the empty dataframes
#then, on the second line the dates are inputted into the evaluate method of the instance.
#this means that when the evaluate method runs, this runs the backtest method which in turn runs the import_data method
          </code>
        </pre>
        <h2>Time Series Momentum</h2>
        <p>This again uses the Strategies class as the basis for this strategy as seen in my Buy and Hold algorithm. In this strategy, a Time Series Momentum Strategy is Created. This takes a positions of every asset in the given basket. If an asset have a negative historic return, then a short position is taken and if it has a positive historic return, then a long position is taken. The lookback period for which returns are calculated is the previous t days. We also only adjust the portfolio weights every q days. Note the first date we can calculate weights will be on date t so we aim to adjust the portfolio weights every q days after this. Then aim to normalise weights by ensuring sum of the absolute values of all weights on any given date is 1.</p>
        <div class="code-caption"><i>Code Snippet 2. Time Series Momentum</i></div>
        <pre>
          <code>
'''
Install yfinance if not installed to run
'''
#pip install yfinance


import numpy as np
import pandas as pd
import pandas_datareader as pdr
import yfinance as yf
import matplotlib.pyplot as plt
import datetime


'''
Setting up class
'''
class Strategies():
    #A class that contains code that strategies later on will inherit from params:
    #codes = list of stock short codes


    #Every class has to have an init method and they define the class specific features.
    #In this case ticker list and two empty dataframes
    def __init__(self,codes):
    #this defines class spacific values
        #so ticker/code list
        self.codes = codes
        #creates 2 empty dataframes
        self.strat = pd.DataFrame()
        self.data = pd.DataFrame()



    def import_data(self, start_date, end_date):
    #this method downloads all data for each backtest from yahoo Finance.
    #and removes any nan values

        #start_date, end_date = string of dates for backtesting with format y-m-d
        #code is another name for ticker
        data = yf.download(self.codes, start_date, end_date)

        #if only one stock code is entered, data is reformatted so that is it the same format as if multiple stock were entered
        if len(self.codes) == 1:
            data.columns = [data.columns, self.codes*len(data.columns)]

        #returns data, and NAN values are removed
        return data.dropna()




    def backtest(self, start_date, end_date):
    #returns a list with elements of a time series from yfinance as well as an array of values between -1 and 1 that represent the strategy over the given period
    #1 represents a long position in one stock, 0 representing a neutral postiion and -1 representing a short position

        #sets up dataframes (defined in the init) to contain data in 1, and then all value weights from the strategy for each stock in the other dataframe
        self.data = self.import_data(start_date, end_date)
        #fills the dataframe with zeros
        self.strat = pd.DataFrame(data = np.zeros([len(self.data), len(self.codes)]), columns = self.codes, index = self.data.index)




    #evaluate method takes a backtest, and evaluates it so calcualte cumulative returns, sharpe and sortino ratios
    def evaluate(self, start_date, end_date, fig_strat=True, fig_other=False, percentage_risk_free_rate = 0.1, **kwargs):
    #returns a dataframe with columns including the daily returns of the portfolio, the cumulative returns, the sharpe ratio and all relevent plot of both the stock price of each stock
    #fig = boolean variable that can be used to produce figures
    #ris_free_rate = average rate of return from a save government issued bond used to calcualte sharpe ratio with
    #**kwargs = any specific keyword arguments that can be passed to the backtesting function to allow for comparison of the backtest for different possible parameters defined in the subclass

        #run the backtest function and define the stock price data to be once again self.data and signals self.strat
        self.strat = self.backtest(start_date, end_date, **kwargs)

        #convert the monthly risk free rate to the daily risk free rate for use when calculating sharpe and sortino ratios
        #e.g. (1+1/100)**(1/21)-1 = (1.01**(0.05)) - 1 =  0.00047 (look up EAR formula)
        #the value of 21 is due to there being 20 trading days in a month
        daily_rate = (1 + percentage_risk_free_rate/100)**(1/21) - 1

        #sets up  new DataFrame which will give the returns of the portfolio
        return_df = pd.DataFrame(columns=["daily returns", "cumulative returns"], index = self.data.index)
        #set return on day 0 to 0
        return_df["daily returns"][0] = 0

        #loops through remaining dates and calculates returns across the portfolio
        for i in range(1, len(self.data)):
            #for each stock, this is 100*value weighting from strategy the previous day*(closing price on current day X - closing price on day X-1)/(closing price on day X-1)
            #hence why if your value weighting is 1 (long position), and the stock goes up, your daily return is posiitve
            #if your weighting is -1 (short position), and the stock goes down, then your daily return is positive
            #this is then summed for the multiple stocks in the portfolio and the portfolio daily returns are given
            return_df["daily returns"][i] = sum(100*self.strat[c][i-1]*(self.data["Adj Close"][c][i]-self.data["Adj Close"][c][i-1])/self.data["Adj Close"][c][i-1] for c in self.codes)

        #calculates the cumulative return for each date
        #it does this by taking the daily return percentage, dividing my 100 and adding 1 to get it into a increase/decrease
        #e.g. daily return of 7% goes >>  (7/100)+1 = 1.07 This happens for all the values in the dataframe
        #then the cumprod returns the cumulative product of a dataframe (NOT SUM) e.g. 1.07*0.96*1.02 not 1.07+0.96+1.02
        #this results is then -1 and multiplied by 100... e.g. (1.12-1)*100 = 12%
        return_df["cumulative returns"] = (((return_df["daily returns"]/100)+1).cumprod()-1)*100
        return_df.dropna()


        #For each of the strategies we went through in the notebook they all require a calculations involving a certain
        #number of historic values. e.g previous percentage returns. As a result our strategies can't start straight away
        #as we need to wait until we have enough previous pieces of data for the code to work and produce signals.

        #calculates the length of time for which the strategy is inactive to begin with
        zero_count = 0
        #While True will run forever until a break command is run.
        while True:
            if sum(abs(self.strat[c].iloc[zero_count]) for c in self.codes):
                #by using iloc[zero_count] when zero_count is 0 it looks at first row, in this is zero then zero_count = 1
                #and then it becomes iloc[1] which searches the second row in the strat dataframe
                #and so on....
                break
            zero_count += 1

            #python syntax allows for the simplification of
            #if not sum(abs(self.strat[c].iloc[zero_count]) for c in self.codes) == 0:
            #to
            #if sum(abs(self.strat[c].iloc[zero_count]) for c in self.codes):

            #^^^^ this basically says that if the rows equals zero, then carry on but if it doesnt equal zero then break
            #so if it is zero 5 times, it bypasses the break and adds to the zero_count, but then the first nonzero value
            #breaks the loop and the while becomes false, and the 5 is stored in zero_count



        #calculates the sharpe ratio, not including the first period of inactivity

        #Sharpe ratio is the sum of the differences in daily returns of the strategy and the risk-free rate
        #over a given period is divivded by the standard devisation of all daily returns.
        #( all return percentages summed/100 - (risk free rate * number of days) ) / standard devisation of all daily returns
        #e.g. ((1.02+0.95+1.06+1.03)/100 - 4*0.0005) / 0.03 = 1.29
        sharpe = ((return_df["daily returns"][zero_count:].sum()/100 - len(return_df[zero_count:]) * daily_rate) / return_df["daily returns"][zero_count:].std())
        print('Sharpe: ', sharpe)

        #Sortino ratio is similar, however we divide by the standard deviation of only the negative or downwards
        #returns (inferring that we only care about negative volatility)
        #This doesnt include the zero_count index in denominator, as there are no negative downturns anyway when there are 0 values, so these are filtered out
        sortino = ((return_df["daily returns"][zero_count:].sum()/100 - len(return_df[zero_count:]) * daily_rate) / return_df["daily returns"][(return_df["daily returns"] < 0)].std())
        print('Sortino: ', sortino)



        #plots figures if fig_strat = TRUE
        if fig_strat:
            #plot of strategy returns
            plt.figure()
            plt.title("Strategy Backtest from" + start_date + " to " + end_date)
            plt.plot(return_df["cumulative returns"])
            plt.show()

        #plots figure if fig_other = TRUE
        if fig_other:
            #plot of all inidividual stocks
            for c in self.codes:
                plt.figure()
                plt.title("Buy and Hold from" + start_date + " to " + end_date + " for " + str(c))
                plt.plot(((self.data["Adj Close"][c].pct_change()+1).cumprod()-1)*100)
                plt.show()
        print('Returns: ', return_df)
        return [return_df, sharpe, sortino]


'''
Class specifically for Time Series Momentum Strat
'''
class StrategyTimeSeriesMomentum(Strategies):


    #parameters include start_Date and end_date
    #t = lookback period
    #q = time length between portfolio adjustments
    def backtest(self, start_date, end_date, q=14, t=50):


        #imports all code from the parent class so we dont have to rewrite them
        Strategies.backtest(self, start_date, end_date)

        #then loop through each time step to calculate the signals
        #start at time t and loop through all remaining time vals (you need the time period t to start the momentum strategy)
        for i in range(t, len(self.data)):

            #every q days, we adjust our portfolio
            #when using the modulo (%) operator, the 'if' statement is TRUE if there is a remainder
            #so say q=5, t=10 and we are on day 30, then i-t = 20 and this is divisable by 5 to give 0 remainder, so continue
            #If it doesnt given an integer, then go to the else statement as we arent adjusting the portfolio on this day
            if not (i-t) % q:

                #a Series is another pandas object which is one column of data along with an index
                #In this case the index is the codes/tickers
                #The data is the returns over the last t days

                #this goes through each code/ticker, and does 100*(the close price of the previous day - close price of the day t days ago) / close price of the day t days ago
                signals = pd.Series(data = (100*(self.data["Adj Close"][c][i-1]-self.data["Adj Close"][c][i-t])/self.data["Adj Close"][c][i-t] for c in self.codes),index = self.codes)
                #this Series inludes the percentrage returns, not the actual returns in pounds!

                #np.sign literally calculates the sign, and if its positive then it put +1, and if negative puts -1
                self.strat.iloc[i] = np.sign(signals)
                #the iloc located the ith row, and makes it equal to the sign of signals

                #the row sum is the sum of the row so if there are 6 stocks, then row_sum is 6 regardless of sign because of abs()
                row_sum = sum((abs(self.strat[c][i]) for c in self.codes))
                if row_sum:
                    self.strat.iloc[i] /= row_sum
            #if it is not one of these q days
            else:
                #set the days weighting equal to the previous days weighting
                self.strat.iloc[i] = self.strat.iloc[i-1]
        return self.strat




'''
Example of a backtest for this strat
'''
testTSM = StrategyTimeSeriesMomentum(["HG=F","GC=F","ZC=F", "SI=F", "PA=F","RB=F"])
testTSM.evaluate("2020-07-24","2022-07-24", t=50)
#in summary, this strategy gives equal weighting to all stocks in the portfolio, but longs some and shorts some, depending
#on values in the strat dataframe. These values are then fed back to the evaluate method where they are combined with the
#data dataframe and the returns and graphs are produced
          </code>
        </pre>
        <h2>Relative Momentum</h2>
        <p>This again, like the Time Momentum and Buy and Hold algorithms uses the Strategies class as a basis. Here we will implement a backtest for the relative momentum strategy. This is a similar strategy to the time series momentum, but instead of going short and long on all stocks, we only go long the the best 'p' performing stocks, and short the worst 'p' performing stocks. So the lookback period is still the previous t days and we still only adjust the portfolio every q days. As usual, across a row in the strat dataframe, the ABSOLUTE values must all add up to 1. Therefore, the weights for the worst stocks are -1/(2p) and for the best p stocks 1/(2p) which if you take the ABSOLUTE values, then they will add to 1.</p>
        <div class="code-caption"><i>Code Snippet 3. Relative Momentum</i></div>
        <pre>
          <code>
'''
Install yfinance if not installed to run
'''
#pip install yfinance


import numpy as np
import pandas as pd
import pandas_datareader as pdr
import yfinance as yf
import matplotlib.pyplot as plt
import datetime


'''
Setting up class
'''
class Strategies():
    #A class that contains code that strategies later on will inherit from params:
    #codes = list of stock short codes


    #Every class has to have an init method and they define the class specific features.
    #In this case ticker list and two empty dataframes
    def __init__(self,codes):
    #this defines class spacific values
        #so ticker/code list
        self.codes = codes
        #creates 2 empty dataframes
        self.strat = pd.DataFrame()
        self.data = pd.DataFrame()



    def import_data(self, start_date, end_date):
    #this method downloads all data for each backtest from yahoo Finance.
    #and removes any nan values

        #start_date, end_date = string of dates for backtesting with format y-m-d
        #code is another name for ticker
        data = yf.download(self.codes, start_date, end_date)

        #if only one stock code is entered, data is reformatted so that is it the same format as if multiple stock were entered
        if len(self.codes) == 1:
            data.columns = [data.columns, self.codes*len(data.columns)]

        #returns data, and NAN values are removed
        return data.dropna()




    def backtest(self, start_date, end_date):
    #returns a list with elements of a time series from yfinance as well as an array of values between -1 and 1 that represent the strategy over the given period
    #1 represents a long position in one stock, 0 representing a neutral postiion and -1 representing a short position

        #sets up dataframes (defined in the init) to contain data in 1, and then all value weights from the strategy for each stock in the other dataframe
        self.data = self.import_data(start_date, end_date)
        #fills the dataframe with zeros
        self.strat = pd.DataFrame(data = np.zeros([len(self.data), len(self.codes)]), columns = self.codes, index = self.data.index)




    #evaluate method takes a backtest, and evaluates it so calcualte cumulative returns, sharpe and sortino ratios
    def evaluate(self, start_date, end_date, fig_strat=True, fig_other=False, percentage_risk_free_rate = 0.1, **kwargs):
    #returns a dataframe with columns including the daily returns of the portfolio, the cumulative returns, the sharpe ratio and all relevent plot of both the stock price of each stock
    #fig = boolean variable that can be used to produce figures
    #ris_free_rate = average rate of return from a save government issued bond used to calcualte sharpe ratio with
    #**kwargs = any specific keyword arguments that can be passed to the backtesting function to allow for comparison of the backtest for different possible parameters defined in the subclass

        #run the backtest function and define the stock price data to be once again self.data and signals self.strat
        self.strat = self.backtest(start_date, end_date, **kwargs)

        #convert the monthly risk free rate to the daily risk free rate for use when calculating sharpe and sortino ratios
        #e.g. (1+1/100)**(1/21)-1 = (1.01**(0.05)) - 1 =  0.00047 (look up EAR formula)
        #the value of 21 is due to there being 20 trading days in a month
        daily_rate = (1 + percentage_risk_free_rate/100)**(1/21) - 1

        #sets up  new DataFrame which will give the returns of the portfolio
        return_df = pd.DataFrame(columns=["daily returns", "cumulative returns"], index = self.data.index)
        #set return on day 0 to 0
        return_df["daily returns"][0] = 0

        #loops through remaining dates and calculates returns across the portfolio
        for i in range(1, len(self.data)):
            #for each stock, this is 100*value weighting from strategy the previous day*(closing price on current day X - closing price on day X-1)/(closing price on day X-1)
            #hence why if your value weighting is 1 (long position), and the stock goes up, your daily return is posiitve
            #if your weighting is -1 (short position), and the stock goes down, then your daily return is positive
            #this is then summed for the multiple stocks in the portfolio and the portfolio daily returns are given
            return_df["daily returns"][i] = sum(100*self.strat[c][i-1]*(self.data["Adj Close"][c][i]-self.data["Adj Close"][c][i-1])/self.data["Adj Close"][c][i-1] for c in self.codes)

        #calculates the cumulative return for each date
        #it does this by taking the daily return percentage, dividing my 100 and adding 1 to get it into a increase/decrease
        #e.g. daily return of 7% goes >>  (7/100)+1 = 1.07 This happens for all the values in the dataframe
        #then the cumprod returns the cumulative product of a dataframe (NOT SUM) e.g. 1.07*0.96*1.02 not 1.07+0.96+1.02
        #this results is then -1 and multiplied by 100... e.g. (1.12-1)*100 = 12%
        return_df["cumulative returns"] = (((return_df["daily returns"]/100)+1).cumprod()-1)*100
        return_df.dropna()


        #For each of the strategies we went through in the notebook they all require a calculations involving a certain
        #number of historic values. e.g previous percentage returns. As a result our strategies can't start straight away
        #as we need to wait until we have enough previous pieces of data for the code to work and produce signals.

        #calculates the length of time for which the strategy is inactive to begin with
        zero_count = 0
        #While True will run forever until a break command is run.
        while True:
            if sum(abs(self.strat[c].iloc[zero_count]) for c in self.codes):
                #by using iloc[zero_count] when zero_count is 0 it looks at first row, in this is zero then zero_count = 1
                #and then it becomes iloc[1] which searches the second row in the strat dataframe
                #and so on....
                break
            zero_count += 1

            #python syntax allows for the simplification of
            #if not sum(abs(self.strat[c].iloc[zero_count]) for c in self.codes) == 0:
            #to
            #if sum(abs(self.strat[c].iloc[zero_count]) for c in self.codes):

            #^^^^ this basically says that if the rows equals zero, then carry on but if it doesnt equal zero then break
            #so if it is zero 5 times, it bypasses the break and adds to the zero_count, but then the first nonzero value
            #breaks the loop and the while becomes false, and the 5 is stored in zero_count



        #calculates the sharpe ratio, not including the first period of inactivity

        #Sharpe ratio is the sum of the differences in daily returns of the strategy and the risk-free rate
        #over a given period is divivded by the standard devisation of all daily returns.
        #( all return percentages summed/100 - (risk free rate * number of days) ) / standard devisation of all daily returns
        #e.g. ((1.02+0.95+1.06+1.03)/100 - 4*0.0005) / 0.03 = 1.29
        sharpe = ((return_df["daily returns"][zero_count:].sum()/100 - len(return_df[zero_count:]) * daily_rate) / return_df["daily returns"][zero_count:].std())
        print('Sharpe: ', sharpe)

        #Sortino ratio is similar, however we divide by the standard deviation of only the negative or downwards
        #returns (inferring that we only care about negative volatility)
        #This doesnt include the zero_count index in denominator, as there are no negative downturns anyway when there are 0 values, so these are filtered out
        sortino = ((return_df["daily returns"][zero_count:].sum()/100 - len(return_df[zero_count:]) * daily_rate) / return_df["daily returns"][(return_df["daily returns"] < 0)].std())
        print('Sortino: ', sortino)



        #plots figures if fig_strat = TRUE
        if fig_strat:
            #plot of strategy returns
            plt.figure()
            plt.title("Strategy Backtest from" + start_date + " to " + end_date)
            plt.plot(return_df["cumulative returns"])
            plt.show()

        #plots figure if fig_other = TRUE
        if fig_other:
            #plot of all inidividual stocks
            for c in self.codes:
                plt.figure()
                plt.title("Buy and Hold from" + start_date + " to " + end_date + " for " + str(c))
                plt.plot(((self.data["Adj Close"][c].pct_change()+1).cumprod()-1)*100)
                plt.show()
        print('Returns: ', return_df)
        return [return_df, sharpe, sortino]


'''
Class specifically for Time Series Momentum Strat
'''
class StrategyRelativeMomentum(Strategies):

    #p = half the number of stock a position is taken in
    #t = lookback period lenth for calculating momentum of each stock
    #q = time length between portfolio adjustments
    def backtest(self, start_date, end_date, p=2, q=15, t=50):

        #import all code from the parent class
        Strategies.backtest(self, start_date, end_date)

        #loop through each time step to calculate the signals
        for i in range(t, len(self.data)):
            if (i-t) % q == 0:

                #this is similar to the time series momentum Pandas Series,
                #for each time step define a variable signals that is a pd Series with
                #index of stock codes, data equal to the percentage returns over the previous
                #t time steps.
                #however here, we also use sort_values to sort into descending order
                signals = pd.Series(data = (100*(self.data["Adj Close"][c][i-1]-self.data["Adj Close"][c][i-t])/self.data["Adj Close"][c][i-t] for c in self.codes), index = self.codes).sort_values()


                #The following code also normalises the values so they sum to 1:

                #select the p codes with a long position (looking at the end of the sorted Series)
                for c in signals[-p:].keys():
                    self.strat[c][i] = 1/(2*p)

                #select p codes with short position by looking at start of Series
                for c in signals[:p].keys():
                    self.strat[c][i] = -1/(2*p)

            else:
                self.strat.iloc[i] = self.strat.iloc[i-1]
        return self.strat




'''
Example of a backtest for this strat
'''
testRM = StrategyRelativeMomentum(["HG=F","GC=F","ZC=F", "SI=F", "PA=F","RB=F"])
testRM.evaluate("2020-07-25","2022-07-25", t=50)
          </code>
        </pre>
      </div>
    </div>

  </div>

  <div class="contact-div">
    <div class="max-1160">
    <p class="contact-text">Interested in learning more? Feel free to reach out...</p>
    <a class="button-link" href="contact.html"><button class="contact-button">Get In Touch</button></a>
    </div>
  </div>

  
    <!-- Content -->
    <div id="container">
      <div class="main-section">
        <div class="article-para" id="para-two">
          <h2>Sentiment Based</h2>
          <p>A project to scrape headlines from news sites, use NLP to score them and suggest whether certain stocks are likely to increase in value or not. Retail trading performed by 'amateur' investors is becoming more and more common. It has more than doubled between 2019 and 2020, and with more 'amateurs' trading and potentially making decisions based on news they see, sentiment analysis will become more important, with global banks already using these strategies. Below is the code to help make these decisions on whether stocks should be brought or sold. Data is extracted using FinViz and then Pythons Natural Language Toolkit helps to analyse the headline data.</p>
          <div class="code-caption"><i>Code Snippet 4. Sentiment Based</i></div>
          <pre>
            <code class="language-python">
#Before running ensure nltk is installed

import os
#used to visualise the graphs
import matplotlib.pyplot as plt
#BeautifulSoup used to parse data from website
from bs4 import BeautifulSoup
#Pandas library to store data in DataFrame objects
import pandas as pd
#Used to perform sentiment analysis on the news headlines
import nltk
nltk.downloader.download('vader_lexicon')
from nltk.sentiment.vader import SentimentIntensityAnalyzer
#requests library to get the data
from urllib.request import urlopen, Request


def sentiment(codes):
    '''
    Extract and Store the Data
    '''
    #to parse a webside, the stock ticker is added to this URL
    web_url = 'https://finviz.com/quote.ashx?t='
    #create an empty dictionary
    news_tables = {}
    #these are the stocks we are analysing
    tickers = codes
    #make iterations, extracting news data for one of the stocks per iteration
    for tick in tickers:
        # add ticker onto URL
        url = web_url + tick
        #request the data
        req = Request(url=url,headers={"User-Agent": "Chrome"})
        response = urlopen(req)
        #parse the html
        html = BeautifulSoup(response,"html.parser")
        #we are looking for headings, found in the HTML of the webpage in a table under the id of 'news-table'
        news_table = html.find(id='news-table')
        #add it into the dictionary with the key being the ticker
        news_tables[tick] = news_table


    '''
    Code to parse date, time and headlines into a Python List
    '''
    #these will go into the empty new_list
    news_list = []
    #loop over the news
    for file_name, news_table in news_tables.items():
        #iterate over all the <tr> tages in news_table containing the headline
        for i in news_table.findAll('tr'):
            #.get_text() function extracts text placed within the <tr> tag, but only text within the <a> tag
            text = i.a.get_text()
            #.split() function splits text placed in <td> tag into a list
            date_scrape = i.td.text.split()
            #if the length of this split data = 1 , time will be loaded as the only element
            if len(date_scrape) == 1:
                time = date_scrape[0]
            #otherwise date will be loaded as the first element and time as the second
            else:
                date = date_scrape[0]
                time = date_scrape[1]
            tick = file_name.split('_')[0]
            news_list.append([tick, date, time, text])

    '''
    Sentiment Analysis Section
    '''
    vader = SentimentIntensityAnalyzer()
    columns = ['ticker', 'date', 'time', 'headline']
    news_df = pd.DataFrame(news_list, columns=columns)
    scores = news_df['headline'].apply(vader.polarity_scores).tolist()
    scores_df = pd.DataFrame(scores)
    news_df = news_df.join(scores_df, rsuffix='_right')
    news_df['date'] = pd.to_datetime(news_df.date).dt.date
    #this is an optional piece of 5 line code that removes totally neutral news
    for index, row in news_df.iterrows():
        if int(row.neu) == 1:
            news_df = news_df.drop(index)
        else:
            pass
    #.head() function returns rows of the dataframe
    print(news_df.head(n=len(news_df)))
    #the compound columns gives us the sentiment scores
    #1 is positive, -1 is negative

    '''
    Visualise the Sentiment Scores
    '''
    plt.rcParams['figure.figsize'] = [10, 6]
    mean_scores = news_df.groupby(['ticker','date']).mean()
    #.unstack() function helps to unstack the ticker column
    mean_scores = mean_scores.unstack()
    #.transpose() obtains the cross-section of compound in the columns axis
    mean_scores = mean_scores.xs('compound', axis="columns").transpose()
    #.plot() and set the kind of graph to 'bar'
    mean_scores.plot(kind = 'bar')
    plt.grid()
    plt.show()


'''
Test of the code with 4 stocks
'''
testsentiment = sentiment(['GOOG', 'AMZN', 'TSLA', 'AAPL'])
            </code>
          </pre>
          <h2>Bollinger Based</h2>
          <p>A systematic trading strategy using Bollinger Bands to create the buy/sell signals. After inputting one stock, the algorithm calculates a moving average, the standard deviations and the upper and lower bounds of the Bollinger Bands. It then produces buy/sell signals if the stocks close price on a given day is below/above the bands. The signals are also visualised on plots and returns are calculated from the inputted time frame of the backtest.</p>
          <div class="code-caption"><i>Code Snippet 5. Bollinger Based</i></div>

          <pre>
            <code>
'''
If not installed, install yfinance
'''
#pip install yfinance


import numpy as np
import pandas as pd
import pandas_datareader as pdr
import yfinance as yf
import matplotlib.pyplot as plt
import datetime


'''
Strategies class which is also used in my other strategy algorithms
'''

class Strategies():
    #A class that contains code that strategies later on will inherit from params:
    #codes = list of stock short codes



    #Classes usually has to have an init method and they define the class specific features.
    #In this case ticker list and two empty dataframes
    def __init__(self,codes):
    #this defines class spacific values
        #so ticker/code list
        self.codes = codes
        #creates 2 empty dataframes
        self.strat = pd.DataFrame()
        self.data = pd.DataFrame()


    def import_data(self, start_date, end_date):
    #this method downloads all data for each backtest from yahoo Finance.
    #and removes any nan values

        #start_date, end_date = string of dates for backtesting with format y-m-d
        #code is another name for ticker
        data = yf.download(self.codes, start_date, end_date)
        #these are additional columns for the Bollinger Strat
        data['SMA'] = 0
        data['STD'] = 0
        data['Upper'] = 0
        data['Lower'] = 0
        #if only one stock code is entered, data is reformatted so that is it the same format as if multiple stock were entered
        if len(self.codes) == 1:
            data.columns = [data.columns, self.codes*len(data.columns)]

        #returns data, and NAN values are removed
        return data.dropna()


    def backtest(self, start_date, end_date):
    #returns a list with elements of a time series from yfinance as well as an array of values between -1 and 1 that represent the strategy over the given period
    #1 represents a long position in one stock, 0 representing a neutral postiion and -1 representing a short position

        #sets up dataframes (defined in the init) to contain data in 1, and then all value weights from the strategy for each stock in the other dataframe
        self.data = self.import_data(start_date, end_date)
        #fills the dataframe with zeros
        self.strat = pd.DataFrame(data = np.zeros([len(self.data), len(self.codes)]), columns = self.codes, index = self.data.index)


    #evaluate method takes a backtest, and evaluates it so calcualte cumulative returns, sharpe and sortino ratios
    def evaluate(self, start_date, end_date, fig_strat=True, fig_other=False, percentage_risk_free_rate = 0.1, **kwargs):
    #returns a dataframe with columns including the daily returns of the portfolio, the cumulative returns, the sharpe ratio and all relevent plot of both the stock price of each stock
    #fig = boolean variable that can be used to produce figures
    #risk_free_rate = average rate of return from a save government issued bond used to calcualte sharpe ratio with
    #**kwargs = any specific keyword arguments that can be passed to the backtesting function to allow for comparison of the backtest for different possible parameters defined in the subclass

        #run the backtest function and define the stock price data to be once again self.data and signals self.strat
        self.strat = self.backtest(start_date, end_date, **kwargs)

        #convert the monthly risk free rate to the daily risk free rate for use when calculating sharpe and sortino ratios
        #e.g. (1+1/100)**(1/21)-1 = (1.01**(0.05)) - 1 =  0.00047 (look up EAR formula)
        #the value of 21 is due to there being 20 trading days in a month
        daily_rate = (1 + percentage_risk_free_rate/100)**(1/21) - 1

        #sets up  new DataFrame which will give the returns of the portfolio
        return_df = pd.DataFrame(columns=["daily returns", "cumulative returns"], index = self.data.index)
        #set return on day 0 to 0
        return_df["daily returns"][0] = 0

        #loops through remaining dates and calculates returns across the portfolio
        for i in range(1, len(self.data)):
            #for each stock, this is 100*value weighting from strategy the previous day*(closing price on current day X - closing price on day X-1)/(closing price on day X-1)
            #hence why if your value weighting is 1 (long position), and the stock goes up, your daily return is posiitve
            #if your weighting is -1 (short position), and the stock goes down, then your daily return is positive
            #this is then summed for the multiple stocks in the portfolio and the portfolio daily returns are given
            return_df["daily returns"][i] = sum(100*self.strat[c][i-1]*(self.data["Adj Close"][c][i]-self.data["Adj Close"][c][i-1])/self.data["Adj Close"][c][i-1] for c in self.codes)

        #calculates the cumulative return for each date
        #it does this by taking the daily return percentage, dividing my 100 and adding 1 to get it into a increase/decrease
        #e.g. daily return of 7% goes >>  (7/100)+1 = 1.07 This happens for all the values in the dataframe
        #then the cumprod returns the cumulative product of a dataframe (NOT SUM) e.g. 1.07*0.96*1.02 not 1.07+0.96+1.02
        #this results is then -1 and multiplied by 100... e.g. (1.12-1)*100 = 12%
        return_df["cumulative returns"] = (((return_df["daily returns"]/100)+1).cumprod()-1)*100
        return_df.dropna()


        #For each of the strategies we went through in the notebook they all require a calculations involving a certain
        #number of historic values. e.g previous percentage returns. As a result our strategies can't start straight away
        #as we need to wait until we have enough previous pieces of data for the code to work and produce signals.

        #calculates the length of time for which the strategy is inactive to begin with
        zero_count = 0
        #While True will run forever until a break command is run.
        while True:
            if sum(abs(self.strat[c].iloc[zero_count]) for c in self.codes):
                #by using iloc[zero_count] when zero_count is 0 it looks at first row, in this is zero then zero_count = 1
                #and then it becomes iloc[1] which searches the second row in the strat dataframe
                #and so on....
                break
            zero_count += 1

            #python syntax allows for the simplification of
            #if not sum(abs(self.strat[c].iloc[zero_count]) for c in self.codes) == 0:
            #to
            #if sum(abs(self.strat[c].iloc[zero_count]) for c in self.codes):

            # ^^^ this says that if the rows equals zero, then carry on but if it doesnt equal zero then break
            #so if it is zero 5 times, it bypasses the break and adds to the zero_count, but then the first nonzero value
            #breaks the loop and the while becomes false, and the 5 is stored in zero_count


        #calculates the sharpe ratio, not including the first period of inactivity

        #Sharpe ratio is the sum of the differences in daily returns of the strategy and the risk-free rate
        #over a given period is divivded by the standard devisation of all daily returns.
        #(all return percentages summed/100 - (risk free rate * number of days) ) / standard devisation of all daily returns
        #e.g. ((1.02+0.95+1.06+1.03)/100 - 4*0.0005) / 0.03 = 1.29
        sharpe = ((return_df["daily returns"][zero_count:].sum()/100 - len(return_df[zero_count:]) * daily_rate) / return_df["daily returns"][zero_count:].std())
        print('Sharpe: ',sharpe)

        #Sortino ratio is similar, however we divide by the standard deviation of only the negative or downwards
        #returns (inferring that we only care about negative volatility)
        #This doesnt include the zero_count index in denominator, as there are no negative downturns anyway when there are 0 values, so these are filtered out
        sortino = ((return_df["daily returns"][zero_count:].sum()/100 - len(return_df[zero_count:]) * daily_rate) / return_df["daily returns"][(return_df["daily returns"] < 0)].std())
        print('Sortino: ',sortino)

        #plots figures if fig_strat = TRUE
        if fig_strat:
            #plot of strategy returns
            plt.figure()
            plt.title("Strategy Backtest from" + start_date + " to " + end_date)
            plt.plot(return_df["cumulative returns"])
            plt.show()

        #plots figure if fig_other = TRUE
        if fig_other:
            #plot of all inidividual stocks
            for c in self.codes:
                plt.figure()
                plt.title("Buy and Hold from" + start_date + " to " + end_date + " for " + str(c))
                plt.plot(((self.data["Adj Close"][c].pct_change()+1).cumprod()-1)*100)
                plt.show()
        print('Returns DataFrame ',return_df)
        return [return_df, sharpe, sortino]



'''
Specific Strategy for Bollinger
'''

class StrategyBollinger(Strategies):
    #this is the Bollinger Strategy Class

    #parameters include start_Date and end_date
    #t = used for the Simple Moving Average in this strat
    def backtest(self, start_date, end_date, t=20):


        #imports all code from the parent class so we dont have to rewrite them
        Strategies.backtest(self, start_date, end_date)


        #calculate the Simple Moving Average (SMA)
        self.data['SMA'] = self.data['Close'].rolling(window=t).mean()
        #get stnadard deviation
        self.data['STD'] = self.data['Close'].rolling(window=t).std()
        #calculate the upper Bollinger band
        self.data['Upper'] = self.data['SMA'] + (self.data['STD'] * 2)
        self.data['Lower'] = self.data['SMA'] - (self.data['STD'] * 2)

        #create a list of columns to keep
        column_list = ['Close', 'SMA', 'Upper', 'Lower']

        #signal_df is a seperate dataframe to display the buy and sell signals on the plot
        signal_df = self.strat.copy()


        for i in range(t, len(self.data)):
            for c in self.codes:
                close = self.data['Close'][c][i]
                upper = self.data['Upper'][c][i]
                lower = self.data['Lower'][c][i]

                if (close > upper): #then you should sell
                    self.strat.iloc[i] = -1
                    signal_df.iloc[i] = -1

                elif (close < lower): # then you should buy
                    self.strat.iloc[i] = 1
                    signal_df.iloc[i] = 1

                else:
                    #notice signal_df not here as that df is only used to show the signal, not used in the 'evaluate' method
                    #this line says that if none of the bollinger bands are exceeded, then this day should be same as previous
                    self.strat.iloc[i] = self.strat.iloc[i-1]


        #pd.set_option('display.max_rows', 10)

        buy_signal = pd.DataFrame(data = np.zeros([len(self.strat), len(self.codes)]), columns = self.codes, index = self.strat.index)
        sell_signal = pd.DataFrame(data = np.zeros([len(self.strat), len(self.codes)]), columns = self.codes, index = self.strat.index)


        #this section gets dates from the signal_df , and adds the dates of buy and sell signals to the buy_signal and sell_signal dataframe respectively
        for i, row in signal_df.iloc[t:].iterrows():
            for c in self.codes:
                if int(row) == 1:
                    sell_signal.loc[i] = 0
                    buy_signal.loc[i] = self.data['Close'][c][i]
                elif int(row) == -1:
                    buy_signal.loc[i] = 0
                    sell_signal.loc[i] = self.data['Close'][c][i]



        #Plot all of the data
        #get the figure and figure size
        fig = plt.figure(figsize=(12,6))
        #add subplot
        ax = fig.add_subplot(1,1,1)
        #get the index values of the dataframe
        x_axis = self.data.index
        #plot and shade the area between upper and and lower band grey
        ax.fill_between(x_axis,self.data['Upper'][self.codes[0]], self.data['Lower'][self.codes[0]], color = 'grey', label='Bollinger Band')
        #Plot closing price and moving average
        ax.plot(x_axis, self.data['Close'], color = 'gold', lw=1, label='Close Price', alpha = 0.5)
        ax.plot(x_axis, self.data['SMA'], color = 'blue', lw=1, label='Simple Moving Average', alpha = 0.5)
        #adds in the green and red  arrows corresponding to the buy and sell signals
        ax.scatter(x_axis, buy_signal, color = 'green', lw = 1, label='Buy', marker='^', alpha = 1)
        ax.scatter(x_axis, sell_signal, color = 'red', lw = 1, label='Sell', marker='v', alpha = 1)

        #set title and show image
        ax.set_title('Bollinger Band for Stock(s)')
        ax.set_xlabel('Date')
        ax.set_ylabel('USD Price ($)')
        plt.xticks(rotation = 45)
        ax.legend()
        plt.show()


        return (self.strat)


'''
Example of the strategy using Apple stock
'''
#only input a single stock
testTSM = StrategyBollinger(["AAPL"])
testTSM.evaluate("2021-07-27","2022-07-27", t=30)
print(testTSM.data)
            </code>
          </pre>
          
          
          <h2>RSI Momentum</h2>
          <p>Relative Strength Index measures the speed and magnitude of a security's recent price changes to evaluate overvalued or undervalued conditions. The value of the RSI ranges from 0 to 1. If the value of the RSI is close to 0, then this indicates that the asset is underpriced. If it is close to 1 then it is overpriced. The boundary values are 0.3 and 0.7 for low and high respectively. The algorithm will:
          <ul> 
            <li>Calculate RSI at each date</li>
            <li>If RSI is less than 0.3 enter long position</li>
            <li>If RSI greater than 0.7 then enter long position</li>
            <li>If RSI is in between then keep the same position as before</li>
          </ul>
          </p>
          <div class="code-caption"><i>Code Snippet 6. RSI Momentum</i></div>
          <pre>
            <code>
'''
Install yfinance if not installed to run
'''
#pip install yfinance


import numpy as np
import pandas as pd
import pandas_datareader as pdr
import yfinance as yf
import matplotlib.pyplot as plt
import datetime


'''
Setting up class
'''
class Strategies():
    #A class that contains code that strategies later on will inherit from params:
    #codes = list of stock short codes


    #Every class has to have an init method and they define the class specific features.
    #In this case ticker list and two empty dataframes
    def __init__(self,codes):
    #this defines class spacific values
        #so ticker/code list
        self.codes = codes
        #creates 2 empty dataframes
        self.strat = pd.DataFrame()
        self.data = pd.DataFrame()



    def import_data(self, start_date, end_date):
    #this method downloads all data for each backtest from yahoo Finance.
    #and removes any nan values

        #start_date, end_date = string of dates for backtesting with format y-m-d
        #code is another name for ticker
        data = yf.download(self.codes, start_date, end_date)

        #if only one stock code is entered, data is reformatted so that is it the same format as if multiple stock were entered
        if len(self.codes) == 1:
            data.columns = [data.columns, self.codes*len(data.columns)]

        #returns data, and NAN values are removed
        return data.dropna()




    def backtest(self, start_date, end_date):
    #returns a list with elements of a time series from yfinance as well as an array of values between -1 and 1 that represent the strategy over the given period
    #1 represents a long position in one stock, 0 representing a neutral postiion and -1 representing a short position

        #sets up dataframes (defined in the init) to contain data in 1, and then all value weights from the strategy for each stock in the other dataframe
        self.data = self.import_data(start_date, end_date)
        #fills the dataframe with zeros
        self.strat = pd.DataFrame(data = np.zeros([len(self.data), len(self.codes)]), columns = self.codes, index = self.data.index)




    #evaluate method takes a backtest, and evaluates it so calcualte cumulative returns, sharpe and sortino ratios
    def evaluate(self, start_date, end_date, fig_strat=True, fig_other=False, percentage_risk_free_rate = 0.1, **kwargs):
    #returns a dataframe with columns including the daily returns of the portfolio, the cumulative returns, the sharpe ratio and all relevent plot of both the stock price of each stock
    #fig = boolean variable that can be used to produce figures
    #ris_free_rate = average rate of return from a save government issued bond used to calcualte sharpe ratio with
    #**kwargs = any specific keyword arguments that can be passed to the backtesting function to allow for comparison of the backtest for different possible parameters defined in the subclass

        #run the backtest function and define the stock price data to be once again self.data and signals self.strat
        self.strat = self.backtest(start_date, end_date, **kwargs)

        #convert the monthly risk free rate to the daily risk free rate for use when calculating sharpe and sortino ratios
        #e.g. (1+1/100)**(1/21)-1 = (1.01**(0.05)) - 1 =  0.00047 (look up EAR formula)
        #the value of 21 is due to there being 20 trading days in a month
        daily_rate = (1 + percentage_risk_free_rate/100)**(1/21) - 1

        #sets up  new DataFrame which will give the returns of the portfolio
        return_df = pd.DataFrame(columns=["daily returns", "cumulative returns"], index = self.data.index)
        #set return on day 0 to 0
        return_df["daily returns"][0] = 0

        #loops through remaining dates and calculates returns across the portfolio
        for i in range(1, len(self.data)):
            #for each stock, this is 100*value weighting from strategy the previous day*(closing price on current day X - closing price on day X-1)/(closing price on day X-1)
            #hence why if your value weighting is 1 (long position), and the stock goes up, your daily return is posiitve
            #if your weighting is -1 (short position), and the stock goes down, then your daily return is positive
            #this is then summed for the multiple stocks in the portfolio and the portfolio daily returns are given
            return_df["daily returns"][i] = sum(100*self.strat[c][i-1]*(self.data["Adj Close"][c][i]-self.data["Adj Close"][c][i-1])/self.data["Adj Close"][c][i-1] for c in self.codes)

        #calculates the cumulative return for each date
        #it does this by taking the daily return percentage, dividing my 100 and adding 1 to get it into a increase/decrease
        #e.g. daily return of 7% goes >>  (7/100)+1 = 1.07 This happens for all the values in the dataframe
        #then the cumprod returns the cumulative product of a dataframe (NOT SUM) e.g. 1.07*0.96*1.02 not 1.07+0.96+1.02
        #this results is then -1 and multiplied by 100... e.g. (1.12-1)*100 = 12%
        return_df["cumulative returns"] = (((return_df["daily returns"]/100)+1).cumprod()-1)*100
        return_df.dropna()


        #For each of the strategies we went through in the notebook they all require a calculations involving a certain
        #number of historic values. e.g previous percentage returns. As a result our strategies can't start straight away
        #as we need to wait until we have enough previous pieces of data for the code to work and produce signals.

        #calculates the length of time for which the strategy is inactive to begin with
        zero_count = 0
        #While True will run forever until a break command is run.
        while True:
            if sum(abs(self.strat[c].iloc[zero_count]) for c in self.codes):
                #by using iloc[zero_count] when zero_count is 0 it looks at first row, in this is zero then zero_count = 1
                #and then it becomes iloc[1] which searches the second row in the strat dataframe
                #and so on....
                break
            zero_count += 1

            #python syntax allows for the simplification of
            #if not sum(abs(self.strat[c].iloc[zero_count]) for c in self.codes) == 0:
            #to
            #if sum(abs(self.strat[c].iloc[zero_count]) for c in self.codes):

            #^^^^ this basically says that if the rows equals zero, then carry on but if it doesnt equal zero then break
            #so if it is zero 5 times, it bypasses the break and adds to the zero_count, but then the first nonzero value
            #breaks the loop and the while becomes false, and the 5 is stored in zero_count



        #calculates the sharpe ratio, not including the first period of inactivity

        #Sharpe ratio is the sum of the differences in daily returns of the strategy and the risk-free rate
        #over a given period is divivded by the standard devisation of all daily returns.
        #( all return percentages summed/100 - (risk free rate * number of days) ) / standard devisation of all daily returns
        #e.g. ((1.02+0.95+1.06+1.03)/100 - 4*0.0005) / 0.03 = 1.29
        sharpe = ((return_df["daily returns"][zero_count:].sum()/100 - len(return_df[zero_count:]) * daily_rate) / return_df["daily returns"][zero_count:].std())
        print('Sharpe: ', sharpe)

        #Sortino ratio is similar, however we divide by the standard deviation of only the negative or downwards
        #returns (inferring that we only care about negative volatility)
        #This doesnt include the zero_count index in denominator, as there are no negative downturns anyway when there are 0 values, so these are filtered out
        sortino = ((return_df["daily returns"][zero_count:].sum()/100 - len(return_df[zero_count:]) * daily_rate) / return_df["daily returns"][(return_df["daily returns"] < 0)].std())
        print('Sortino: ', sortino)



        #plots figures if fig_strat = TRUE
        if fig_strat:
            #plot of strategy returns
            plt.figure()
            plt.title("Strategy Backtest from" + start_date + " to " + end_date)
            plt.plot(return_df["cumulative returns"])
            plt.show()

        #plots figure if fig_other = TRUE
        if fig_other:
            #plot of all inidividual stocks
            for c in self.codes:
                plt.figure()
                plt.title("Buy and Hold from" + start_date + " to " + end_date + " for " + str(c))
                plt.plot(((self.data["Adj Close"][c].pct_change()+1).cumprod()-1)*100)
                plt.show()
        print('Returns: ', return_df)
        return [return_df, sharpe, sortino]


'''
Class specifically for RSI Strat
'''
class StrategyRSI(Strategies):
    def backtest(self, start_date, end_date, t=5, q=5, weighting=False):

        #still had to import previous code from parent backtest function
        Strategies.backtest(self, start_date, end_date)

        #initisalise the RSI dataframe, and this calculates the RSI values for each stock at each time instance
        RSI = pd.DataFrame(data = np.zeros([len(self.data), len(self.codes)]), columns = self.codes, index = self.data.index)


        #then we loop through the time index
        for i in range(t, len(self.data)):

            #pct_change computes the percentage change from i-t to i
            data_pct_change = self.data["Adj Close"][i-t:i].pct_change()

            #basically calculating the mean of the positive returns over that period
            #we use a Boolean index for this with: data_pct_change[c] >= 0
            #it says 'is the percantage change for some given code data_pct_change[c] greater than 0. If it is then include it in the mean
            numerator = pd.Series(data = (data_pct_change[c][(data_pct_change[c] >= 0 )].mean() for c in self.codes), index = self.codes)

            #mean of the negative returns
            denominator = pd.Series(data = (data_pct_change[c][(data_pct_change[c] <= 0 )].mean() for c in self.codes), index = self.codes)

            #an issue is say we look a period of 10 days and all returns are positive, then denominator has no values to calculate a mean
            #so python will say its not a number. And same if all negative returns

            #so we treat these two cases here
            for c in self.codes:

                #if no positive returns in past t days, set RSI to 0 as we think its underbrought
                if numerator.isnull()[c]:
                    RSI[c][i] = 0

                #if no negative returns in past t days, set RSI to 1 as we think its overbrought
                elif denominator.isnull()[c]:
                    RSI[c][i] = 1

                #otherwise, we can calulate the RSI
                else:
                    RSI[c][i] = 1 - 1/(1-numerator[c]/denominator[c])



                #if it is not being weighted
                if not weighting:
                    #if the RSI value is less that 0.3 for that stock on that day, then go long
                    if RSI[c][i] < 0.3:
                        self.strat[c][i] = 1

                    #and continue going long on that stock until it becomes larger than 0.7
                    #we then exit the trade and enter a merket neutral position, not shorting
                    elif RSI[c][i] > 0.7:
                        self.strat[c][i] = 0

                    #if it doesnt go into any of these boundaries, then keep the same as before
                    else:
                        self.strat[c][i] = self.strat[c][i-1]

                #if weighted
                else:
                    if (i-t) % q:
                        self.strat.iloc[i] = (0.8 - RSI.iloc[i])
                    else:
                        self.strat.iloc[i] = self.strat.iloc[i-1]

            #again we have to normalise across the rows as we did in previous strategies
            #unlike the first two strategies, we dont know how many assets we are going to take a position in so we cant just divide by the number of assets
            #e.g. if we have 5 assets and long positions in all of them, then we have to divide by 5,
            #but if we have invested in only 2 stocks, then we have to divide by 2 instead of the assets avaliable
            row_sum = sum(abs(self.strat.iloc[i]))
            if row_sum:
                self.strat.iloc[i] /= row_sum
            else:
                self.strat.iloc[i] = self.strat.iloc[i-1]


        return self.strat



'''
Example of a backtest for this strat
'''
testRSI = StrategyRSI(["^FTSE","^GSPC","AAPL","GC=F","ZC=F","HG=F","SIEGY","SIE.DE"])
testRSI.evaluate("2020-07-25","2022-07-25", t=5, weighting=False)
#basic RSI without the weighting function
            </code>
          </pre>

        </div>
      </div>
      <div class="download-div">
        <a class="download-button" href="projects/Strategy_Scripts.zip" download>Download All Scripts</a>
      </div>
    </div>





  
  <div id="container">
    <div class="main-section">
  
      <div class="section-break">
        <p>Related Articles</p>
      </div>
  

      <div class="grid-container">
      <a href="rocket.html" class="thumbnail">
        <div class="grid-item-footer" >
          <img class="item-photo" src="/assets/rocket.png" alt="Item 1 Photo">
          <div class="item-tags">Real Options Analysis</div>
          <div class="item-header">Space Transportation Economic Analysis Under Uncertainty
            <img class="item-arrow" src="assets/arrow.svg"/>
          </div>
        </div>
        </a> 
  
        <a href="music.html" class="thumbnail">
          <div class="grid-item-footer">
            <img class="item-photo" src="/assets/music.png" alt="Item 2 Photo">
            <div class="item-tags">Data Science</div>
            <div class="item-header">Predicting Future Song Popularity
              <img class="item-arrow" src="assets/arrow.svg"/>
            </div>
          </div>
          </a>
  
        <a href="solar.html" class="thumbnail">
          <div class="grid-item-footer">
            <img class="item-photo" src="/assets/solar.png" alt="Item 3 Photo">
            <div class="item-tags">Optimization</div>
            <div class="item-header">Optimisation of a Solar Farm Layout
              <img class="item-arrow" src="assets/arrow.svg"/>
            </div>
          </div>
        </a>

        <a href="rocket.html" class="thumbnail">
          <div class="grid-item-footer">
            <img class="item-photo" src="/assets/rocket.png" alt="Item 1 Photo">
            <div class="item-tags">Real Options Analysis</div>
            <div class="item-header">Space Transportation Economic Analysis Under Uncertainty
              <img class="item-arrow" src="assets/arrow.svg"/>
            </div>
          </div>
        </a>
  
      </div>
    </div>
  </div>


  <div class="banner">
    <div id="container" class="banner-content">
      <h3>An Introduction to Systematic Trading Strategies</h3>


      <div class="article-icon-bar">
        <!-- download button -->
        <a id="downloadButton" class="copy-button" href="projects/Strategy_Scripts.zip" download>
        <svg class="article-download" width="252" height="147" viewBox="0 0 252 147" fill="none" xmlns="http://www.w3.org/2000/svg">
          <g clip-path="url(#clip0_90_32)">
          <path fill="currentColor" d="M16.7216 140H5.21591V100.727H17.4119C21.1577 100.727 24.3601 101.507 27.0192 103.067C29.6911 104.626 31.7365 106.864 33.1555 109.778C34.5746 112.693 35.2841 116.19 35.2841 120.268C35.2841 124.384 34.5554 127.919 33.098 130.872C31.6534 133.812 29.544 136.069 26.7699 137.641C24.0085 139.214 20.6591 140 16.7216 140ZM8.80185 136.778H16.5107C19.8857 136.778 22.7109 136.114 24.9865 134.784C27.2621 133.455 28.9688 131.556 30.1065 129.089C31.2443 126.621 31.8132 123.681 31.8132 120.268C31.8004 116.88 31.2379 113.965 30.1257 111.523C29.0263 109.082 27.3899 107.209 25.2166 105.905C23.0561 104.601 20.3842 103.949 17.201 103.949H8.80185V136.778ZM54.7143 140.614C52.1703 140.614 49.9203 139.968 47.9643 138.677C46.0211 137.386 44.4998 135.602 43.4004 133.327C42.301 131.038 41.7512 128.398 41.7512 125.407C41.7512 122.39 42.301 119.737 43.4004 117.449C44.4998 115.148 46.0211 113.358 47.9643 112.08C49.9203 110.788 52.1703 110.143 54.7143 110.143C57.2583 110.143 59.502 110.788 61.4451 112.08C63.3883 113.371 64.9096 115.161 66.0091 117.449C67.1213 119.737 67.6774 122.39 67.6774 125.407C67.6774 128.398 67.1277 131.038 66.0282 133.327C64.9288 135.602 63.4011 137.386 61.4451 138.677C59.502 139.968 57.2583 140.614 54.7143 140.614ZM54.7143 137.488C56.7598 137.488 58.492 136.938 59.911 135.839C61.3301 134.739 62.4039 133.276 63.1326 131.447C63.8741 129.619 64.2449 127.606 64.2449 125.407C64.2449 123.208 63.8741 121.188 63.1326 119.347C62.4039 117.506 61.3301 116.03 59.911 114.918C58.492 113.805 56.7598 113.249 54.7143 113.249C52.6816 113.249 50.9494 113.805 49.5176 114.918C48.0985 116.03 47.0183 117.506 46.2768 119.347C45.5481 121.188 45.1838 123.208 45.1838 125.407C45.1838 127.606 45.5481 129.619 46.2768 131.447C47.0183 133.276 48.0985 134.739 49.5176 135.839C50.9366 136.938 52.6689 137.488 54.7143 137.488ZM80.7076 140L71.8098 110.545H75.415L82.3951 134.842H82.6444L89.6053 110.545H93.2296L100.133 134.784H100.401L107.382 110.545H110.987L102.089 140H98.5605L91.5804 115.857H91.2161L84.236 140H80.7076ZM121.035 121.591V140H117.622V110.545H120.939V115.167H121.246C121.936 113.658 123.01 112.45 124.468 111.543C125.938 110.622 127.753 110.162 129.914 110.162C131.895 110.162 133.634 110.577 135.129 111.408C136.638 112.227 137.808 113.435 138.639 115.033C139.482 116.631 139.904 118.593 139.904 120.92V140H136.491V121.131C136.491 118.714 135.813 116.803 134.458 115.397C133.116 113.991 131.313 113.288 129.051 113.288C127.504 113.288 126.129 113.62 124.928 114.285C123.726 114.95 122.774 115.908 122.07 117.161C121.38 118.401 121.035 119.878 121.035 121.591ZM152.306 100.727V140H148.893V100.727H152.306ZM172.787 140.614C170.243 140.614 167.993 139.968 166.037 138.677C164.093 137.386 162.572 135.602 161.473 133.327C160.373 131.038 159.824 128.398 159.824 125.407C159.824 122.39 160.373 119.737 161.473 117.449C162.572 115.148 164.093 113.358 166.037 112.08C167.993 110.788 170.243 110.143 172.787 110.143C175.331 110.143 177.574 110.788 179.517 112.08C181.461 113.371 182.982 115.161 184.081 117.449C185.194 119.737 185.75 122.39 185.75 125.407C185.75 128.398 185.2 131.038 184.1 133.327C183.001 135.602 181.473 137.386 179.517 138.677C177.574 139.968 175.331 140.614 172.787 140.614ZM172.787 137.488C174.832 137.488 176.564 136.938 177.983 135.839C179.402 134.739 180.476 133.276 181.205 131.447C181.946 129.619 182.317 127.606 182.317 125.407C182.317 123.208 181.946 121.188 181.205 119.347C180.476 117.506 179.402 116.03 177.983 114.918C176.564 113.805 174.832 113.249 172.787 113.249C170.754 113.249 169.022 113.805 167.59 114.918C166.171 116.03 165.091 117.506 164.349 119.347C163.62 121.188 163.256 123.208 163.256 125.407C163.256 127.606 163.62 129.619 164.349 131.447C165.091 133.276 166.171 134.739 167.59 135.839C169.009 136.938 170.741 137.488 172.787 137.488ZM201.469 140.671C199.692 140.671 198.069 140.326 196.599 139.636C195.128 138.933 193.959 137.923 193.089 136.606C192.22 135.276 191.785 133.665 191.785 131.773C191.785 130.316 192.06 129.089 192.61 128.092C193.16 127.094 193.939 126.276 194.949 125.637C195.959 124.998 197.155 124.493 198.535 124.122C199.916 123.751 201.437 123.464 203.099 123.259C204.748 123.055 206.142 122.876 207.28 122.722C208.43 122.569 209.306 122.326 209.907 121.994C210.508 121.661 210.808 121.124 210.808 120.383V119.692C210.808 117.685 210.207 116.107 209.006 114.956C207.817 113.793 206.104 113.211 203.866 113.211C201.744 113.211 200.012 113.678 198.67 114.611C197.34 115.544 196.407 116.643 195.87 117.909L192.629 116.739C193.294 115.129 194.214 113.844 195.39 112.885C196.567 111.913 197.883 111.217 199.341 110.795C200.798 110.36 202.275 110.143 203.77 110.143C204.895 110.143 206.065 110.29 207.28 110.584C208.507 110.878 209.645 111.389 210.693 112.118C211.741 112.834 212.591 113.837 213.243 115.129C213.895 116.407 214.221 118.031 214.221 119.999V140H210.808V135.34H210.597C210.188 136.21 209.581 137.053 208.775 137.871C207.97 138.69 206.96 139.361 205.746 139.885C204.531 140.409 203.106 140.671 201.469 140.671ZM201.93 137.545C203.745 137.545 205.317 137.143 206.647 136.337C207.976 135.532 208.999 134.464 209.715 133.135C210.444 131.793 210.808 130.316 210.808 128.705V124.448C210.552 124.691 210.124 124.908 209.523 125.1C208.935 125.292 208.251 125.464 207.471 125.618C206.704 125.759 205.937 125.88 205.17 125.982C204.403 126.085 203.713 126.174 203.099 126.251C201.437 126.455 200.018 126.775 198.842 127.21C197.666 127.644 196.765 128.245 196.138 129.012C195.512 129.766 195.199 130.738 195.199 131.927C195.199 133.717 195.838 135.104 197.116 136.088C198.395 137.06 199.999 137.545 201.93 137.545ZM233.906 140.614C231.49 140.614 229.374 139.974 227.558 138.696C225.743 137.418 224.324 135.634 223.301 133.346C222.291 131.058 221.786 128.392 221.786 125.349C221.786 122.32 222.291 119.667 223.301 117.391C224.324 115.103 225.749 113.326 227.578 112.06C229.406 110.782 231.534 110.143 233.963 110.143C235.753 110.143 237.242 110.462 238.431 111.102C239.62 111.728 240.573 112.508 241.289 113.441C242.004 114.374 242.561 115.282 242.957 116.164H243.264V100.727H246.696V140H243.36V134.535H242.957C242.561 135.43 241.998 136.35 241.269 137.296C240.541 138.229 239.575 139.016 238.374 139.655C237.185 140.294 235.695 140.614 233.906 140.614ZM234.308 137.488C236.213 137.488 237.837 136.97 239.179 135.935C240.521 134.886 241.544 133.448 242.247 131.62C242.963 129.779 243.321 127.67 243.321 125.292C243.321 122.94 242.97 120.862 242.267 119.06C241.563 117.244 240.541 115.825 239.198 114.803C237.856 113.767 236.226 113.249 234.308 113.249C232.34 113.249 230.678 113.786 229.323 114.86C227.98 115.921 226.958 117.359 226.254 119.175C225.564 120.99 225.219 123.029 225.219 125.292C225.219 127.58 225.57 129.645 226.274 131.486C226.977 133.327 227.999 134.79 229.342 135.877C230.697 136.951 232.352 137.488 234.308 137.488Z"/>
          <path id="download-lines" stroke="currentColor" d="M87 76H159" stroke-width="3" stroke-linecap="round"/>
          <path fill="currentColor" d="M121.939 65.0607C122.525 65.6464 123.475 65.6464 124.061 65.0607L133.607 55.5147C134.192 54.9289 134.192 53.9792 133.607 53.3934C133.021 52.8076 132.071 52.8076 131.485 53.3934L123 61.8787L114.515 53.3934C113.929 52.8076 112.979 52.8076 112.393 53.3934C111.808 53.9792 111.808 54.9289 112.393 55.5147L121.939 65.0607ZM124.5 6C124.5 5.17157 123.828 4.5 123 4.5C122.172 4.5 121.5 5.17157 121.5 6L124.5 6ZM124.5 64L124.5 6L121.5 6L121.5 64L124.5 64Z"/>
          <path id="download-lines" stroke="currentColor" d="M113.5 54.5L102 43M132 55L144 43" stroke-width="3" stroke-linejoin="round"/>
          </g>
          <defs>
          <clipPath  id="clip0_90_32">
          <rect  width="252" height="147" fill="white"/>
          </clipPath>
          </defs>
        </svg>
      </a>
        <!-- share button -->
        <button id="copyButton" class="copy-button">
          <svg class="article-icon" width="147" height="147" viewBox="0 0 147 147" fill="none" xmlns="http://www.w3.org/2000/svg">
            <circle cx="92.5" cy="18.5" r="10" stroke="currentColor" stroke-width="3"/>
            <circle cx="92.5" cy="62.5" r="10" stroke="currentColor" stroke-width="3"/>
            <circle cx="52.5" cy="40.5" r="10" stroke="currentColor" stroke-width="3"/>
            <line x1="60.7183" y1="46.6832" x2="82.7183" y2="58.6832" stroke="currentColor" stroke-width="3"/>
            <line y1="-1.5" x2="25.0599" y2="-1.5" transform="matrix(-0.877896 0.478852 0.478852 0.877896 84 23)" stroke="currentColor" stroke-width="3"/>
            <path fill="currentColor" d="M26.5398 109.545C26.3224 107.359 25.3572 105.621 23.6442 104.33C21.9311 103.038 19.777 102.393 17.1818 102.393C15.3537 102.393 13.7429 102.706 12.3494 103.332C10.9688 103.959 9.8821 104.828 9.08949 105.94C8.30966 107.04 7.91974 108.293 7.91974 109.699C7.91974 110.734 8.14347 111.642 8.59091 112.422C9.03835 113.202 9.6392 113.873 10.3935 114.435C11.1605 114.985 12.0043 115.458 12.9247 115.854C13.858 116.251 14.7976 116.583 15.7436 116.852L19.8857 118.04C21.1385 118.386 22.3913 118.827 23.6442 119.364C24.897 119.901 26.0412 120.578 27.0767 121.396C28.125 122.202 28.9624 123.192 29.5888 124.369C30.228 125.532 30.5476 126.932 30.5476 128.568C30.5476 130.665 30.0043 132.55 28.9176 134.225C27.831 135.9 26.2713 137.229 24.2386 138.214C22.206 139.185 19.7706 139.671 16.9325 139.671C14.2607 139.671 11.9403 139.23 9.97159 138.348C8.00284 137.453 6.45597 136.219 5.33097 134.647C4.20597 133.075 3.57315 131.253 3.43253 129.182H7.11435C7.24219 130.729 7.75355 132.039 8.64844 133.113C9.54332 134.187 10.7067 135.005 12.1385 135.567C13.5703 136.117 15.1683 136.392 16.9325 136.392C18.8885 136.392 20.6271 136.066 22.1484 135.414C23.6825 134.749 24.8842 133.829 25.7536 132.653C26.6357 131.464 27.0767 130.083 27.0767 128.511C27.0767 127.181 26.7315 126.069 26.0412 125.174C25.3509 124.266 24.3857 123.506 23.1456 122.892C21.9183 122.278 20.4929 121.735 18.8693 121.262L14.1712 119.881C11.0902 118.961 8.69957 117.689 6.99929 116.065C5.29901 114.442 4.44886 112.371 4.44886 109.852C4.44886 107.743 5.01136 105.889 6.13636 104.291C7.27415 102.68 8.80824 101.428 10.7386 100.533C12.6818 99.625 14.8615 99.1712 17.2777 99.1712C19.7195 99.1712 21.88 99.6186 23.7592 100.513C25.6385 101.408 27.1278 102.642 28.2273 104.214C29.3395 105.774 29.934 107.551 30.0107 109.545H26.5398ZM41.8807 120.591V139H38.4673V99.7273H41.8807V114.167H42.1875C42.8778 112.646 43.9453 111.431 45.3899 110.523C46.8473 109.616 48.6882 109.162 50.9126 109.162C52.907 109.162 54.6584 109.571 56.1669 110.389C57.6754 111.207 58.8516 112.415 59.6953 114.013C60.5391 115.612 60.9609 117.58 60.9609 119.92V139H57.5284V120.131C57.5284 117.702 56.8509 115.79 55.4957 114.397C54.1534 112.991 52.3381 112.288 50.0497 112.288C48.4773 112.288 47.0774 112.62 45.8501 113.285C44.6229 113.95 43.6513 114.908 42.9354 116.161C42.2322 117.401 41.8807 118.878 41.8807 120.591ZM78.1763 139.671C76.3993 139.671 74.7757 139.326 73.3056 138.636C71.8354 137.933 70.6657 136.923 69.7963 135.606C68.927 134.276 68.4924 132.665 68.4924 130.773C68.4924 129.316 68.7672 128.089 69.3169 127.092C69.8667 126.094 70.6465 125.276 71.6564 124.637C72.6664 123.998 73.8617 123.493 75.2424 123.122C76.623 122.751 78.1444 122.464 79.8063 122.259C81.4554 122.055 82.8489 121.876 83.9867 121.722C85.1373 121.569 86.013 121.326 86.6138 120.994C87.2147 120.661 87.5151 120.124 87.5151 119.383V118.692C87.5151 116.685 86.9142 115.107 85.7125 113.956C84.5236 112.793 82.8105 112.211 80.5733 112.211C78.4512 112.211 76.7189 112.678 75.3766 113.611C74.0471 114.544 73.1138 115.643 72.5769 116.909L69.3361 115.739C70.0009 114.129 70.9213 112.844 72.0975 111.885C73.2736 110.913 74.5904 110.217 76.0478 109.795C77.5051 109.36 78.9817 109.143 80.4775 109.143C81.6025 109.143 82.7722 109.29 83.9867 109.584C85.214 109.878 86.3517 110.389 87.4 111.118C88.4483 111.834 89.2985 112.837 89.9505 114.129C90.6025 115.407 90.9284 117.031 90.9284 118.999V139H87.5151V134.34H87.3042C86.8951 135.21 86.2878 136.053 85.4824 136.871C84.677 137.69 83.6671 138.361 82.4526 138.885C81.2381 139.409 79.8127 139.671 78.1763 139.671ZM78.6365 136.545C80.4519 136.545 82.0243 136.143 83.3539 135.337C84.6834 134.532 85.7061 133.464 86.4221 132.135C87.1507 130.793 87.5151 129.316 87.5151 127.705V123.448C87.2594 123.691 86.8311 123.908 86.2303 124.1C85.6422 124.292 84.9583 124.464 84.1784 124.618C83.4114 124.759 82.6444 124.88 81.8773 124.982C81.1103 125.085 80.4199 125.174 79.8063 125.251C78.1444 125.455 76.7253 125.775 75.5492 126.21C74.373 126.644 73.4718 127.245 72.8453 128.012C72.2189 128.766 71.9057 129.738 71.9057 130.927C71.9057 132.717 72.5449 134.104 73.8233 135.088C75.1017 136.06 76.7061 136.545 78.6365 136.545ZM100.008 139V109.545H103.326V114.071H103.575C104.163 112.588 105.186 111.393 106.643 110.485C108.113 109.565 109.775 109.104 111.629 109.104C111.91 109.104 112.224 109.111 112.569 109.124C112.914 109.136 113.202 109.149 113.432 109.162V112.633C113.278 112.607 113.01 112.569 112.626 112.518C112.243 112.467 111.827 112.441 111.38 112.441C109.846 112.441 108.478 112.767 107.276 113.419C106.087 114.058 105.148 114.947 104.457 116.085C103.767 117.222 103.422 118.52 103.422 119.977V139H100.008ZM130.268 139.614C127.52 139.614 125.142 138.974 123.135 137.696C121.128 136.405 119.574 134.621 118.475 132.346C117.388 130.058 116.845 127.424 116.845 124.445C116.845 121.479 117.388 118.846 118.475 116.545C119.574 114.231 121.089 112.422 123.02 111.118C124.963 109.801 127.206 109.143 129.751 109.143C131.349 109.143 132.889 109.437 134.372 110.025C135.855 110.6 137.184 111.489 138.361 112.69C139.55 113.879 140.489 115.381 141.18 117.197C141.87 118.999 142.215 121.134 142.215 123.602V125.289H119.204V122.278H138.725C138.725 120.386 138.341 118.686 137.574 117.178C136.82 115.656 135.765 114.455 134.41 113.572C133.068 112.69 131.515 112.249 129.751 112.249C127.884 112.249 126.241 112.748 124.822 113.745C123.403 114.742 122.291 116.059 121.486 117.695C120.693 119.332 120.29 121.121 120.278 123.065V124.867C120.278 127.207 120.68 129.252 121.486 131.004C122.304 132.742 123.461 134.091 124.956 135.05C126.452 136.009 128.223 136.488 130.268 136.488C131.662 136.488 132.883 136.271 133.931 135.836C134.992 135.401 135.881 134.82 136.596 134.091C137.325 133.349 137.875 132.538 138.246 131.656L141.486 132.71C141.039 133.95 140.304 135.094 139.281 136.143C138.271 137.191 137.006 138.035 135.484 138.674C133.976 139.3 132.237 139.614 130.268 139.614Z" fill="currentColor"/>
            </svg>
        </button>
      </div>




    </div>
  <div class="scroll-indicator"></div>
  </div>









 <!-- Footer -->
 <div id="instance-footer"></div>

 <!-- Script -->
 <script src="main.js"></script>
 
 <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
 <!-- and it's easy to individually load additional languages -->
 <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script>
 <script>hljs.highlightAll();</script>

</body>
</html>
